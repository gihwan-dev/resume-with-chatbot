---
companyId: "exem"
title: "대규모 데이터 화면용 공용 데이터 그리드 개발"
company: "Exem"
description: "대규모 데이터 조회와 빈번한 열 조작이 동시에 일어나는 화면을 위해, 20+ 기능을 지원하는 공용 데이터 그리드를 제약 조건 중심으로 재설계해 성능과 확장성을 함께 확보한 사례"
dateStart: 2025-07-01
techStack: ["React", "TanStack Table", "TanStack Virtual", "Vitest"]
priority: 2
storyThread:
  tldrSummary: "초기 table 기반 구현은 virtualization, 고정 컬럼, 그룹 헤더, 리사이즈를 함께 만족시키기 어려웠고 기능 조합이 늘수록 회귀 리스크가 커졌습니다. 리팩토링 전후 동작을 통합 테스트로 먼저 고정한 뒤 div 기반 렌더링으로 1차 전환했지만, 컬럼 너비 변경 시 인접 컬럼 재분배가 필요한 스펙 변경에 맞춰 Row absolute + Cell flex 구조로 2차 재설계했습니다. 이후 리사이즈 제약 조건과 컨테이너 분할 규칙을 명시하고 Core - State - UI, Custom Feature, 호환표 기반 문서/테스트 체계를 함께 정리해 공용 인프라로 고정했으며 DOM 노드와 리사이즈 처리 시간을 동시에 개선했습니다."
  keyMetrics:
    - value: "90%"
      label: "DOM 노드 감소"
      description: "가상화 경계를 다시 설계해 대규모 데이터 화면의 렌더링 부담을 낮췄습니다."
    - value: "22ms -> 0.5ms"
      label: "리사이즈 처리 시간"
      description: "레이아웃/폭 계산 경로를 단순화해 열 조작 응답성을 안정화했습니다."
    - value: "20+"
      label: "지원 기능 수"
      description: "단일 화면 최적화가 아니라 공용 데이터 그리드 인프라로 기능 조합을 확장했습니다."
  coreApproach: "table 기반 시작점에서 드러난 구조 제약을 해소하기 위해 렌더링 모델, 리사이즈 제약 규칙, 기능 호환 관리, 검증 체계를 함께 재설계해 공용 인프라로 고정했습니다."
  problemDefinition: "초기 table 기반 구조에서는 virtualization, 고정 컬럼, 그룹 헤더, 리사이즈를 함께 구현할 때 구조 충돌이 반복됐고, 대량 데이터 환경에서 렌더링 비용과 열 조작 비용이 동시에 증가했습니다. 공용 그리드 특성상 화면별 보정이 아니라 기반 구조 자체를 바꾸는 접근이 필요했습니다."
  problemPoints:
    - "table 레이아웃 제약으로 virtualization·고정 컬럼·그룹 헤더·리사이즈 조합 시 구조 충돌이 반복됐습니다."
    - "대량 데이터에서 렌더링 비용과 열 조작 계산 비용이 함께 커져 화면 응답성이 흔들렸습니다."
    - "기능 수가 늘수록 조합별 스펙 충돌과 회귀 범위를 수동으로 관리하기 어려웠습니다."
    - "공용 컴포넌트라 화면별 임시 분기보다 공통 제약을 명시하는 구조 재설계가 우선 과제였습니다."
  decisions:
    - title: "table 유지 대신 div 기반 렌더링 구조로 전환"
      whyThisChoice: "초기 table 기반 구현에서 기능 조합이 늘어날수록 구조 충돌이 누적되어, 부분 보정으로는 공용 인프라 확장성을 확보하기 어려웠습니다."
      alternative: "table 구조를 유지한 채 화면별 보정 로직을 누적"
      tradeOff: "table 유지는 단기 변경 비용이 낮지만 기능 조합이 늘수록 유지보수 비용이 증가하고, div 전환은 초기 마이그레이션 비용이 크더라도 장기 확장성 확보에 유리했습니다."
    - title: "Cell absolute 1차 구조에서 Row absolute + Cell flex 2차 구조로 재설계"
      whyThisChoice: "초기 셀 단위 absolute 전략은 동작했지만, 인접 컬럼 재분배가 필요한 리사이즈 스펙 변경을 수용하기에 제약이 컸습니다."
      alternative: "셀 단위 absolute 계산 로직을 계속 확장"
      tradeOff: "기존 구조 확장은 단기 대응은 빠르지만 계산 복잡도가 급격히 증가하고, row/cell 역할 분리 재설계는 초기 비용이 있어도 이후 스펙 변경 대응력이 높았습니다."
    - title: "임시 분기 누적 대신 제약 조건을 규칙으로 명시"
      whyThisChoice: "리사이즈, 고정 컬럼, 그룹 헤더 동작을 조건문으로 누적하면 조합별 동작 일관성이 깨져 회귀 리스크가 커졌습니다."
      alternative: "이슈 발생 시 케이스별 분기 추가"
      tradeOff: "케이스 분기는 도입이 쉬우나 장기적으로 예외가 폭증하고, 제약 규칙 명시는 설계 비용이 들지만 변경 영향 범위를 예측 가능하게 만들었습니다."
    - title: "Core - State - UI + 호환표 + 테스트 체계로 공용 인프라화"
      whyThisChoice: "기능 수가 늘수록 상태/렌더 결합과 문서-테스트 불일치가 비용의 주원인이 되어 구조적 분리와 검증 기준 통합이 필요했습니다."
      alternative: "기존 컴포넌트 중심 구조를 유지하며 테스트만 추가"
      tradeOff: "테스트만 추가하면 구조 결합 문제는 남고, 계층 분리와 호환표 기반 관리는 초기 정리 비용이 있지만 기능 확장 시 변경 범위를 줄이고 회귀 안정성을 높입니다."
  implementationHighlights:
    - "리팩토링 전후 동작을 통합 테스트로 먼저 고정한 뒤 table 기반 구조에서 div 기반 렌더링으로 전환했습니다."
    - "1차로 Cell absolute positioning을 적용했지만, 리사이즈 스펙 변경에 맞춰 Row absolute + Cell flex 구조로 2차 재설계했습니다."
    - "리사이즈/고정 컬럼/그룹 헤더/컨테이너 분할 규칙을 명시해 기능 조합 시 동작 일관성을 확보했습니다."
    - "제어/비제어 인터페이스, Custom Feature, Core - State - UI 분리와 호환표 기반 문서/테스트/TDD 프로세스를 공용 표준으로 정리했습니다."
  implementationGroups:
    - title: "시간 순서 구현 흐름"
      items:
        - "리팩토링 전후 동작을 통합 테스트로 선행 정비해 기존 스펙을 고정했습니다."
        - "초기 table 기반 구조를 div 렌더링으로 전환하고 1차로 Cell absolute positioning을 적용했습니다."
        - "리사이즈 시 인접 컬럼 재분배가 필요한 스펙 변경에 맞춰 2차로 Row absolute + Cell flex 구조를 도입했습니다."
        - "제어/비제어 인터페이스를 일관화하고 Custom Feature + Core - State - UI 계층으로 분리했습니다."
        - "기능 호환표를 기준으로 Storybook 시나리오, 통합 테스트, TDD 회귀 흐름을 함께 관리했습니다."
    - title: "핵심 제약 조건 규칙"
      items:
        - "기본 정책상 테이블 내부 빈 공간을 최소화하고 예외 시나리오는 별도 규칙과 테스트로 관리합니다."
        - "기본적으로 컬럼 너비 변경 영향은 우측 컬럼으로 전달하며, 마지막 리프 헤더는 컨테이너 전체 너비 계산에 직접 영향을 줍니다."
        - "우측 고정 컬럼 리사이즈는 반대 방향(좌측 컬럼)으로만 영향이 전달되도록 분리합니다."
        - "리사이즈 핸들은 리프 헤더에만 부여하고, 첫/마지막 리프 헤더는 부모 계층 수를 반영한 높이의 핸들을 제공해 그룹 헤더 리사이즈처럼 동작하게 합니다."
        - "부모 그룹 헤더 너비는 자식 리프 헤더 너비 합으로 계산하고, 컨테이너는 상/중/하 및 각 영역의 좌/중/우 분할로 고정/스크롤 조합을 다룹니다."
  validationImpact:
    measurementMethod: "정량 검증은 React Profiler, Chrome DevTools Performance, Performance API로 동일 시나리오를 반복 측정해 DOM 노드 수와 리사이즈 처리 시간을 비교했습니다. 정성 검증은 기능 호환표를 기준으로 Storybook 시나리오, browser 통합 테스트, 회귀 타깃 문서를 함께 관리해 조합 안정성을 확인했습니다."
    metrics:
      - "DOM 노드: 약 90% 감소"
      - "리사이즈 처리: 22ms -> 0.5ms"
      - "기능 조합 안정성: 호환표 기준 Storybook·통합 테스트·회귀 타깃 문서로 관리"
    operationalImpact: "대규모 데이터 화면에서도 성능과 유지보수성을 함께 확보할 수 있는 공용 그리드 기반으로 전환됐고, 성능 개선이 화면별 보정이 아닌 인프라 품질 향상으로 이어졌습니다."
  lessonsLearned: "대규모 그리드는 레이아웃 모델, 제약 조건 모델링, 검증 체계를 함께 설계해야 지속 가능합니다.\n공용 UI 인프라는 기능이 늘어날수록 구현 기법보다 스펙 관리 방식이 더 중요해집니다.\n테스트와 문서는 사후 산출물이 아니라 복잡한 조합을 다루는 설계 도구가 됩니다."
---

## TL;DR

table 기반 시작점의 구조 제약을 넘기 위해 통합 테스트로 동작을 먼저 고정하고, div 렌더링 전환과 두 차례 레이아웃 재설계를 거쳐 공용 데이터 그리드 인프라를 다시 설계했습니다.

## 문제 정의

virtualization, 고정 컬럼, 그룹 헤더, 리사이즈를 함께 지원할 때 table 구조 충돌과 계산 비용 증가가 반복됐고, 공용 컴포넌트 특성상 화면별 보정이 아닌 기반 구조 전환이 필요했습니다.

## 핵심 의사결정

div 전환, Cell absolute에서 Row absolute + Cell flex로의 2차 재설계, 제약 규칙 명시, Core - State - UI와 호환표/테스트 체계 정리를 한 묶음으로 가져갔습니다.

## 구현 전략

통합 테스트 선행 정비 이후 table -> div 전환, 리사이즈 스펙 변경 대응 재설계, 제약 규칙 명시, 제어/비제어 인터페이스와 Custom Feature 기반 구조 분리를 시간 순서로 진행했습니다.

## 검증 및 결과

정량 지표는 DOM 노드와 리사이즈 시간을 반복 측정으로 검증했고, 정성 지표는 호환표 기반 Storybook/통합 테스트/회귀 문서로 기능 조합 안정성을 관리했습니다.

## 회고

공용 UI 인프라는 기법 하나보다 레이아웃 모델, 제약 조건 모델링, 검증 체계를 함께 설계할 때 지속 가능한 품질을 확보할 수 있습니다.
