---
companyId: "exem"
title: "데이터 그리드 개발"
company: "Exem"
description: "table 기반 병목을 div + virtualization 아키텍처로 전환해 DOM 90% 감소와 리사이즈 44배 개선을 달성한 공용 그리드 설계 사례"
dateStart: 2025-07-01
updatedAt: 2026-02-22
techStack: ["React", "TanStack Table", "TanStack Virtual", "Vitest"]
priority: 2
storyThread:
  tldrSummary: "table 구조를 div + virtualization으로 전환해 고밀도 데이터 화면의 렌더·조작 병목을 동시에 제거했습니다."
  keyMetrics:
    - value: "90%"
      label: "동시 렌더링 DOM 감소"
      description: "가상화 경계를 재설계해 대량 화면 렌더 부담을 크게 낮췄습니다."
    - value: "22ms -> 0.5ms"
      label: "리사이즈 처리 44배 개선"
      description: "열 계산 경로를 단순화해 리사이즈 지연을 안정적으로 줄였습니다."
    - value: "110ms -> 20~30ms"
      label: "인터랙션 지연 단축"
      description: "변경 행 중심 렌더링으로 조작 응답성을 개선했습니다."
  coreApproach: "구조 전환, 계산 경로 단순화, 이벤트/회귀 체계를 한 세트로 묶어 성능과 안정성을 함께 확보했습니다."
  problemDefinition: "table 구조 제약과 누적 계산 비용, 전면 리렌더 오버헤드가 겹쳐 고밀도 화면 상호작용 품질이 무너진 상태였습니다."
  problemPoints:
    - "고정 영역과 가상 스크롤을 함께 구현할 때 구조 충돌이 잦았습니다."
    - "열 계산 누적 비용으로 리사이즈·정렬 조작 지연이 커졌습니다."
    - "기능 조합이 늘었지만 회귀 검증은 수동 중심이라 릴리즈 리스크가 높았습니다."
  decisions:
    - title: "table 유지 대신 div + virtualization 전환"
      whyThisChoice: "부분 최적화만으로는 구조 상한을 넘기 어렵고 공용 컴포넌트 확장성도 확보할 수 없었습니다."
      alternative: "table 구조를 유지하는 대신 div + virtualization으로 전환"
      tradeOff: "table 구조는 시맨틱 이점이 있지만 가상화 제약이 크고, div + virtualization은 접근성 보완 비용이 있어도 성능 상한을 열 수 있어 전환을 선택했습니다."
    - title: "정밀 수동 계산 대신 브라우저 레이아웃 위임"
      whyThisChoice: "세밀 제어보다 계산 경로 단순화와 유지보수 비용 절감이 장기적으로 더 중요했습니다."
      alternative: "정밀 수동 계산을 유지하는 대신 flex 기반 폭 정책으로 브라우저 레이아웃에 위임"
      tradeOff: "정밀 수동 계산은 제어가 세밀하지만 결함 위험이 높고, flex 기반 위임은 일부 제어를 포기하더라도 계산 비용을 크게 줄일 수 있어 위임 방식을 선택했습니다."
    - title: "핸들러 분산 유지 대신 이벤트 위임 + 회귀 게이트"
      whyThisChoice: "성능 개선을 릴리즈 품질로 고정하려면 이벤트 모델과 검증 체계를 동시에 단순화해야 했습니다."
      alternative: "핸들러 분산 구조를 유지하는 대신 컨테이너 이벤트 위임과 통합 회귀 게이트를 적용"
      tradeOff: "기존 핸들러 분산 구조는 초기 변경이 작지만 누적 오버헤드가 크고, 이벤트 위임과 통합 회귀 게이트는 초기 구축 비용이 있어도 장기 안정성이 높아 해당 구조를 선택했습니다."
  implementationHighlights:
    - "가상화 친화 렌더 경계를 설계하고 고정/스크롤 영역을 패널 구조로 분리했습니다."
    - "열 배치 계산을 flex 기반 폭 정책으로 단순화해 누적 계산 오버헤드를 줄였습니다."
    - "React.memo 커스텀 비교로 변경된 행만 렌더링되도록 경계를 조정했습니다."
    - "컨테이너 이벤트 위임과 600+ 조합 회귀 게이트를 표준화해 릴리즈 위험을 낮췄습니다."
  validationImpact:
    measurementMethod: "React Profiler, Chrome DevTools Performance, Performance API로 동일 시나리오를 30회 반복 측정해 평균과 p95를 비교했습니다."
    metrics:
      - "DOM 노드: 약 90% 감소"
      - "리사이즈 처리: 22ms -> 0.5ms"
      - "인터랙션 지연: 110ms -> 20~30ms"
    operationalImpact: "고밀도 모니터링 화면에서도 스크롤·정렬·리사이즈가 끊기지 않아 운영 판단 속도와 릴리즈 신뢰성을 함께 확보했습니다."
  lessonsLearned: "대규모 그리드 최적화는 기법 하나보다 구조·계산·검증 체계를 함께 바꿀 때 지속됩니다.\n성능 개선을 제품 품질로 남기려면 회귀 게이트를 같이 설계해야 합니다."
---

## TL;DR

table 구조를 div + virtualization으로 전환해 렌더링/인터랙션 병목을 동시에 줄였습니다.

## 문제 정의

구조 제약과 계산 오버헤드, 회귀 리스크가 결합돼 단순 최적화로는 개선이 유지되지 않았습니다.

## 핵심 의사결정

구조 전환, 계산 위임, 이벤트 위임 + 회귀 게이트를 하나의 설계 세트로 묶어 실행했습니다.

## 구현 전략

렌더 경계 재설계와 계산 단순화를 중심으로 공용 컴포넌트 유지비를 줄였습니다.

## 검증 및 결과

30회 반복 측정에서 DOM, 리사이즈, 인터랙션 지표가 동시에 개선됐습니다.

## What I Learned

공용 UI의 성능은 코드 미세 조정보다 아키텍처와 운영 검증 체계를 먼저 설계할 때 지속됩니다.
