---
companyId: "exem"
title: "대규모 데이터 화면용 공용 데이터 그리드 개발"
company: "Exem"
description: "대규모 데이터 조회와 빈번한 열 조작이 동시에 일어나는 화면을 위해, 20+ 기능을 지원하는 공용 데이터 그리드를 제약 조건 중심으로 재설계해 성능과 확장성을 함께 확보한 사례"
dateStart: 2025-07-01
techStack: ["React", "TanStack Table", "TanStack Virtual", "Vitest"]
priority: 2
storyThread:
  tldrSummary: "초기 table 기반 구현은 virtualization, 고정 컬럼, 그룹 헤더, 리사이즈를 함께 만족시키기 어려웠고 기능 조합이 늘수록 회귀 리스크가 커졌습니다. 리팩토링 전후 동작을 통합 테스트로 먼저 고정한 뒤 div 기반 렌더링으로 1차 전환하고 Cell absolute 구조를 적용했습니다. 이후 컬럼 너비 변경 시 인접 컬럼 재분배가 필요한 스펙 변경에 맞춰 Row absolute + Cell flex 구조로 2차 재설계하고, 리사이즈 제약과 컨테이너 분할 규칙을 명시했습니다. Core - State - UI 분리와 호환표 기반 검증 운영을 정착시켜 기능 조합 관리와 성능 개선을 함께 달성했습니다."
  keyMetrics:
    - value: "90%"
      label: "DOM 노드 감소"
      description: "가상화 경계를 다시 설계해 대규모 데이터 화면의 렌더링 부담을 낮췄습니다."
    - value: "22ms -> 0.5ms"
      label: "리사이즈 처리 시간"
      description: "레이아웃/폭 계산 경로를 단순화해 열 조작 응답성을 안정화했습니다."
    - value: "호환표 기반"
      label: "기능 조합 검증"
      description: "Storybook·브라우저 기반 통합 테스트·회귀 타깃 문서를 같은 기준으로 운영해 조합별 스펙을 관리했습니다."
  coreApproach: "table 기반 제약을 해소하기 위해 렌더링 모델과 리사이즈 규칙을 재설계하고, Core - State - UI 분리로 기능 로직을 UI에서 분리했습니다. 이후 호환표를 기준으로 문서·테스트 운영 체계를 정리해 기능 조합 검증을 지속 가능한 방식으로 운영했습니다."
  problemDefinition: "초기 table 기반 구조에서는 virtualization, 고정 컬럼, 그룹 헤더, 리사이즈를 함께 구현할 때 구조 충돌이 반복됐고, 대량 데이터 환경에서 렌더링 비용과 열 조작 비용이 동시에 증가했습니다. 공용 그리드 특성상 화면별 보정이 아니라 기반 구조 자체를 바꾸는 접근이 필요했습니다."
  problemPoints:
    - "table 레이아웃 제약으로 virtualization·고정 컬럼·그룹 헤더·리사이즈 조합 시 구조 충돌이 반복됐습니다."
    - "대량 데이터에서 렌더링 비용과 열 조작 계산 비용이 함께 커져 화면 응답성이 흔들렸습니다."
    - "기능 수가 늘수록 조합별 스펙 충돌과 회귀 범위를 수동으로 관리하기 어려웠습니다."
    - "공용 컴포넌트라 화면별 임시 분기보다 공통 제약을 명시하는 구조 재설계가 우선 과제였습니다."
  decisions:
    - title: "table 유지 대신 div 기반 렌더링 구조로 전환"
      whyThisChoice: "초기 table 기반 구현에서 기능 조합이 늘어날수록 구조 충돌이 누적되어, 부분 보정으로는 공용 인프라 확장성을 확보하기 어려웠습니다."
      alternative: "table 유지 + 예외 분기 누적"
      tradeOff: "table 유지는 단기 변경 비용이 낮지만 기능 조합이 늘수록 유지보수 비용이 증가하고, div 전환은 초기 마이그레이션 비용이 크더라도 장기 확장성 확보에 유리했습니다."
    - title: "Cell absolute 1차 구조에서 Row absolute + Cell flex 2차 구조로 재설계"
      whyThisChoice: "초기 셀 단위 absolute 전략은 동작했지만, 인접 컬럼 재분배가 필요한 리사이즈 스펙 변경을 수용하기에 제약이 컸습니다."
      alternative: "cell absolute 확장"
      tradeOff: "기존 구조 확장은 단기 대응은 빠르지만 계산 복잡도가 급격히 증가하고, row/cell 역할 분리 재설계는 초기 비용이 있어도 이후 스펙 변경 대응력이 높았습니다."
    - title: "임시 분기 누적 대신 제약 조건을 규칙으로 명시"
      whyThisChoice: "리사이즈, 고정 컬럼, 그룹 헤더 동작을 조건문으로 누적하면 조합별 동작 일관성이 깨져 회귀 리스크가 커졌습니다."
      alternative: "케이스별 조건문 추가"
      tradeOff: "케이스 분기는 도입이 쉬우나 장기적으로 예외가 폭증하고, 제약 규칙 명시는 설계 비용이 들지만 변경 영향 범위를 예측 가능하게 만들었습니다."
    - title: "Core - State - UI 분리로 테스트 가능성과 확장성 확보"
      whyThisChoice: "기능이 늘어날수록 상태, 기능 정책, 렌더링이 컴포넌트 안에 함께 엉키면 테스트 경계를 나누기 어려워지고 구현이 특정 프레임워크에 종속되기 쉬웠습니다. 그래서 Controlled/Uncontrolled 인터페이스와 Custom Feature를 포함한 Core - State - UI 구조로 역할을 분리해 기능 로직을 UI에서 독립시키는 방향을 선택했습니다."
      alternative: "컴포넌트 결합 유지"
      tradeOff: "컴포넌트 결합을 유지한 채 테스트만 보강하면 UI 종속성과 회귀 비용이 계속 남습니다. 구조를 먼저 분리하면 테스트 작성이 쉬워지고, 이후 다른 프레임워크 바인딩으로 확장할 때도 핵심 로직을 재사용할 수 있습니다."
  implementationHighlights:
    - "리팩토링 전후 동작을 통합 테스트로 먼저 고정한 뒤 table 기반 구조에서 div 기반 렌더링으로 전환했습니다."
    - "1차로 Cell absolute positioning을 적용했지만, 리사이즈 스펙 변경에 맞춰 Row absolute + Cell flex 구조로 2차 재설계했습니다."
    - "리사이즈/고정 컬럼/그룹 헤더/컨테이너 분할 규칙을 명시해 기능 조합 시 동작 일관성을 확보했습니다."
    - "제어/비제어 인터페이스, Custom Feature, Core - State - UI 분리와 호환표 기반 문서/테스트/TDD 프로세스를 공용 표준으로 정리했습니다."
  implementationGroups:
    - title: "시간 순서 구현 흐름"
      items:
        - "리팩토링 전후 동작을 통합 테스트로 선행 정비해 기존 스펙을 고정했습니다."
        - "초기 table 기반 구조를 div 렌더링으로 전환하고 1차로 Cell absolute positioning을 적용했습니다."
        - "리사이즈 시 인접 컬럼 재분배가 필요한 스펙 변경에 맞춰 2차로 Row absolute + Cell flex 구조를 도입했습니다."
        - "제어/비제어 인터페이스를 일관화하고 Custom Feature + Core - State - UI 계층으로 분리했습니다."
        - "기능 로직을 UI에서 분리한 뒤에는 호환표를 기준으로 Storybook 시나리오, 브라우저 기반 통합 테스트, 회귀 타깃 문서를 함께 관리해 기능 조합별 스펙을 검증 가능하게 만들었습니다."
    - title: "핵심 제약 조건 규칙"
      items:
        - "기본 정책상 테이블 내부 빈 공간을 최소화하고 예외 시나리오는 별도 규칙과 테스트로 관리합니다."
        - "기본적으로 컬럼 너비 변경 영향은 우측 컬럼으로 전달하며, 마지막 리프 헤더는 컨테이너 전체 너비 계산에 직접 영향을 줍니다."
        - "우측 고정 컬럼 리사이즈는 반대 방향(좌측 컬럼)으로만 영향이 전달되도록 분리합니다."
        - "리사이즈 핸들은 리프 헤더에만 부여하고, 첫/마지막 리프 헤더는 부모 계층 수를 반영한 높이의 핸들을 제공해 그룹 헤더 리사이즈처럼 동작하게 합니다."
        - "부모 그룹 헤더 너비는 자식 리프 헤더 너비 합으로 계산하고, 컨테이너는 상/중/하 및 각 영역의 좌/중/우 분할로 고정/스크롤 조합을 다룹니다."
  validationImpact:
    measurementMethod: "정량 검증은 React Profiler, Chrome DevTools Performance, Performance API로 동일 시나리오를 반복 측정해 DOM 노드 수와 리사이즈 처리 시간을 비교했습니다. 정성 검증은 기능 호환표를 기준으로 Storybook 시나리오, 브라우저 기반 통합 테스트, 회귀 타깃 문서를 함께 관리해 조합 안정성을 확인했습니다."
    metrics:
      - "DOM 노드: 약 90% 감소"
      - "리사이즈 처리: 22ms -> 0.5ms"
      - "기능 조합 검증 체계: 호환표 기반 Storybook·브라우저 기반 통합 테스트·회귀 타깃 문서 운영"
    operationalImpact: "계층 분리 덕분에 기능 로직의 테스트 경계를 더 명확하게 나눌 수 있었고, 호환표 기반 검증 체계를 통해 기능 조합이 늘어나는 상황에서도 문서·테스트·구현의 기준을 일관되게 유지할 수 있었습니다. 그 결과 대규모 데이터 화면에서도 성능과 유지보수성을 함께 확보했습니다."
  lessonsLearned: "대규모 그리드는 레이아웃 모델, 제약 조건 모델링, 검증 체계를 함께 설계해야 지속 가능합니다.\n공용 UI 인프라는 기능이 늘어날수록 구현 기법보다 스펙 관리 방식이 더 중요해집니다.\n테스트와 문서는 사후 산출물이 아니라 복잡한 조합을 다루는 설계 도구가 됩니다."
---

## TL;DR

table 기반 한계를 통합 테스트로 먼저 고정한 뒤 div 렌더링으로 1차 전환했습니다. 이후 리사이즈 스펙 변경에 맞춰 Row absolute + Cell flex 구조로 2차 재설계하고, Core - State - UI 분리와 호환표 기반 검증 운영으로 조합 확장성을 확보했습니다.

## 문제 정의

table 구조에서는 기능 조합 충돌과 계산 비용 증가가 반복돼, 공용 컴포넌트 기준에서 기반 구조 전환이 필요했습니다.

## 핵심 의사결정

div 전환과 2차 레이아웃 재설계로 구조를 바꾸고, Core - State - UI 분리로 테스트 경계를 분명히 했습니다. 호환표는 구현 전략과 검증 운영 기준으로 내려 조합 스펙을 일관되게 관리했습니다.

## 구현 전략

통합 테스트 선행 정비 후 table -> div 전환, 1차/2차 재설계, 제약 규칙 명시, Core - State - UI 분리, 호환표 기반 Storybook/브라우저 통합 테스트 운영을 순차적으로 진행했습니다.

## 검증 및 결과

정량 지표는 DOM 노드와 리사이즈 시간을 반복 측정으로 검증했고, 정성 지표는 호환표 기반 Storybook/브라우저 통합 테스트/회귀 문서 운영으로 기능 조합 검증 체계를 유지했습니다.

## 회고

공용 UI 인프라는 기법 하나보다 레이아웃 모델, 제약 조건 모델링, 검증 체계를 함께 설계할 때 지속 가능한 품질을 확보할 수 있습니다.
