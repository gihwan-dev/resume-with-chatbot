---
companyId: "exem"
title: "데이터 그리드 개발"
company: "Exem"
description: "차세대 대시보드의 공용 데이터 그리드 아키텍처를 재설계해 렌더링 성능과 확장성을 동시에 개선"
dateStart: 2025-07-01
updatedAt: 2026-02-15
techStack: ["React", "TanStack Table", "TanStack Virtual", "Vitest"]
priority: 2
storyThread:
  context: "table 기반 구조의 가상화 한계, O(n) 레이아웃 계산, 전면 리렌더링/이벤트 바인딩 오버헤드가 겹치며 고밀도 그리드 상호작용 성능이 저하된 상태였습니다."
  impacts:
    - value: "90%"
      label: "동시 렌더링 DOM 노드 감소"
      description: "가상화 중심 렌더링 경계 재설계로 대량 데이터 화면의 DOM 부담을 크게 줄였습니다."
    - value: "22ms -> 0.5ms"
      label: "리사이즈 처리 44배 개선"
      description: "열 배치 계산을 단순화하고 브라우저 레이아웃 엔진 활용도를 높여 리사이즈 지연을 단축했습니다."
    - value: "110ms -> 20~30ms"
      label: "인터랙션 지연 단축"
      description: "불필요한 리렌더를 줄여 스크롤/정렬/조작 시 체감 반응성을 안정화했습니다."
  threads:
    - issueTitle: "table 구조 제약으로 가상화 적용이 어렵고 DOM이 폭증하는 문제"
      problems:
        - "모든 행이 DOM에 렌더링되어 노드 수가 23,000+까지 증가했습니다."
        - "고정/가상 스크롤을 함께 유지하기 어려워 구조적 확장성이 낮았습니다."
      thoughtProcess: "부분 최적화보다 렌더링 경계를 재설계해야 성능과 기능 조합을 동시에 확보할 수 있다고 판단했습니다."
      actions:
        - "table 유지 vs div 전환의 트레이드오프를 비교한 뒤 div 기반 레이아웃으로 전환했습니다."
        - "TanStack Virtual 기반 행 가상화를 적용하고 고정 영역을 패널 구조로 분리했습니다."
      comparison:
        beforeLabel: "기존 <table> 기반 아키텍처"
        afterLabel: "가상화 및 div 기반 아키텍처"
        before:
          - "DOM에 모든 행이 렌더링되어 노드 수가 23,000+까지 증가했습니다."
          - "리사이즈·레이아웃 재계산에 평균 22ms가 소요됐습니다."
          - "스크롤/정렬 시 변경 없는 행까지 함께 리렌더링됐습니다."
        after:
          - "가상화 렌더링 경계 재설계로 DOM 노드를 약 90% 줄였습니다."
          - "리사이즈 처리 시간을 22ms에서 0.5ms로 단축했습니다."
          - "행 단위 렌더 최적화로 인터랙션 지연을 20~30ms 수준으로 안정화했습니다."
      result: "렌더링 구조가 가상화 친화적으로 바뀌며 DOM 노드를 약 90% 줄였습니다."
    - issueTitle: "열 위치 계산과 전면 리렌더 오버헤드로 상호작용 지연이 커지는 문제"
      problems:
        - "column.getStart() 누적 계산으로 열 수 증가 시 비용이 커졌습니다."
        - "스크롤/정렬 시 변경 없는 행까지 리렌더링되었습니다."
      thoughtProcess: "수치 개선을 유지하려면 계산 경로 단순화와 렌더 경계 축소를 함께 적용해야 한다고 판단했습니다."
      actions:
        - "left/width 직접 계산을 줄이고 flex 기반 폭 정책으로 전환했습니다."
        - "React.memo 커스텀 비교로 변경된 행만 리렌더링되도록 최적화했습니다."
      result: "리사이즈 처리 시간 22ms -> 0.5ms, 인터랙션 지연 110ms -> 20~30ms 수준으로 단축했습니다."
    - issueTitle: "이벤트 핸들러 분산과 기능 조합 회귀 위험이 높은 문제"
      problems:
        - "셀/행 단위 이벤트 바인딩으로 리렌더링마다 클로저 생성/폐기가 반복됐습니다."
        - "기능 조합이 늘수록 회귀 리스크가 커졌습니다."
      thoughtProcess: "성능 개선을 제품 신뢰성으로 연결하려면 이벤트 모델 단순화와 자동 회귀 검증이 필수라고 판단했습니다."
      actions:
        - "클릭/키보드 처리를 컨테이너 이벤트 위임으로 전환했습니다."
        - "기능 조합 통합 테스트를 600+ 케이스로 확장해 회귀 게이트를 구축했습니다."
      result: "이벤트 오버헤드가 감소하고 성능/기능 안정성을 함께 유지할 수 있는 운영 기반을 확보했습니다."
  lessonsLearned: "그리드 성능 문제는 렌더링 기법 단일 개선으로 끝나지 않으며, 레이아웃 구조·이벤트 모델·회귀 검증을 함께 설계해야 지속 가능한 품질이 확보된다는 점을 확인했습니다."
---

import CompareToggle from "@/components/portfolio/compare-toggle.astro"

#### 고성능 데이터 그리드 라이브러리 아키텍처 개선

**[TanStack Table 기반 데이터 그리드 개선기](https://velog.io/@koreanthuglife/Tanstack-Table-%EA%B8%B0%EB%B0%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B7%B8%EB%A6%AC%EB%93%9C-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0)**

<CompareToggle beforeLabel="기존 <table> 기반 아키텍처" afterLabel="가상화 및 div 기반 아키텍처">
  <div slot="before">
    - DOM에 모든 행이 렌더링되어 노드 수가 23,000개 이상으로 급증
    - 리사이즈 및 레이아웃 재계산에 과도한 비용 발생 (평균 22ms)
    - 스크롤/정렬 시 화면 전체가 리렌더링되는 병목 현상
  </div>
  <div slot="after">
    - **DOM 노드 90% 감소**: 화면에 보이는 요소(View Port)만 렌더링
    - **리사이즈 속도 44배 향상**: (22ms → 0.5ms) 레이아웃 엔진 최적화
    - **CPU 사용률 절반 감소**: 변경된 행만 리렌더링하도록 Memoization 적용
  </div>
</CompareToggle>

<h3 id="problem">Problem</h3>

* `<table>` 기반 구조에서는 네이티브 레이아웃 방식을 우회하지 않으면 행 가상화를 적용하기 어려워, 모든 행을 DOM에 렌더링해야 했고 노드가 **23,000+**까지 증가해 리플로우 비용이 급격히 커졌습니다.
* `tr`/`th` 같은 경직된 요소 계층 구조로 인해 리사이즈 핸들러를 헤더와 동일 계층에 배치하는 것과 같은 유연한 레이아웃 구조를 설계하는게 어려웠습니다.
* 셀 위치 계산이 `column.getStart()` 누적 합산에 의존해 열 수에 비례한 `O(n)` 비용이 발생했습니다.
* 컨테이너 리사이즈, 스크롤 등의 처리에서 모든 셀이 리렌더링되는 오버헤드가 존재했습니다.
* 셀·행마다 클릭·키보드 이벤트 핸들러가 개별 등록되어, 리렌더링마다 수백 개의 클로저가 재생성·폐기되면서 GC 부담이 증가했습니다.
* 스크롤·정렬 등 상호작용 시 변경이 없는 행까지 전체 셀이 리렌더링되어 불필요한 연산이 반복됐습니다.

<h3 id="decision">Decision</h3>

* `<table>` 유지(Sticky 고정·동기화 보정) vs `div` 기반(가상화 친화적 렌더 경계) 트레이드오프를 비교한 뒤, 공용 그리드 확장성을 위해 `div` 기반 레이아웃으로 전환했습니다.
* `div` 전환 후에도 `role`/ARIA 속성으로 접근성(선택·정렬 상태 포함)을 유지했습니다.
* 고정 행/열을 3×3 패널로 분리하는 구조를 설계하고, `TanStack Virtual`로 행 가상화를 적용해 Row `position: absolute` / Cell `display: flex` 구조로 렌더링 경계를 재구성했습니다.
* 셀 배치에서 `left`·`width` 직접 계산과 `column.getStart()` 누적 합산을 제거하고, `flex` 기반 폭 정책(고정폭/자동폭)으로 전환해 레이아웃 계산을 브라우저 엔진에 위임했습니다.
* `React.memo`에 커스텀 비교 함수를 적용해 행 단위로 props 변경을 판별하고, 변경된 행만 리렌더링되도록 최적화했습니다.
* 셀·행 단위로 등록되던 클릭·키보드 이벤트 핸들러를 컨테이너 레벨 이벤트 위임으로 전환해 핸들러 바인딩을 단일 지점으로 집약했습니다.

<h3 id="result">Result</h3>

* 동시 렌더링 DOM 노드를 약 **90%** 감소시키고, 인터랙션 지연을 **110ms**에서 **20~30ms**로 단축해 고밀도 모니터링 화면의 체감 반응성을 개선했습니다.
* 컨테이너 리사이즈 처리 시간을 **22ms**에서 **0.5ms**(약 **44배**)로 단축했습니다.
* 스크롤 시 전체 셀 리렌더링을 변경된 행만 리렌더링으로 축소해 CPU 최대 사용률을 약 **50%** 감소시켰습니다.
* 이벤트 리스너를 약 **50%** 감소시켜(Chrome DevTools 기준) 리렌더링 시 클로저 생성·폐기에 따른 GC 부담을 절감했습니다.
* 고정 영역 × 가상 스크롤 × 리사이즈 × 컬럼 폭 등등 다양한 기능 조합을 **600개 이상** 통합 테스트로 회귀를 조기에 차단했습니다.

<h3 id="retrospective">Retrospective</h3>

* 성능 병목은 렌더링 기법 하나로 해결되지 않았고, 레이아웃 구조·이벤트 모델·회귀 테스트를 함께 설계해야 지속 가능한 개선이 가능하다는 교훈을 얻었습니다.
* 공용 컴포넌트는 초기 구현 속도보다 확장 시나리오를 먼저 설계해야 이후 기능 조합 비용과 회귀 위험을 낮출 수 있음을 확인했습니다.
