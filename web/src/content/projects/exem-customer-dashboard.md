---
companyId: "exem"
title: "고객 특화 DB 모니터링 대시보드 개발"
company: "Exem"
description: "고객별 운영 시나리오를 단일 대시보드 구조로 통합해 장애 인지 시간을 10초에서 3초로 단축한 아키텍처 전환 사례"
dateStart: 2025-01-01
updatedAt: 2026-02-22
techStack: ["React", "TypeScript", "TanStack Table", "TanStack Query", "React Grid Layout", "Zustand", "Vite", "Playwright"]
priority: 1
storyThread:
  context: "Vue 레거시 대시보드의 분산 폴링 제어, 카드형 UI의 낮은 데이터 밀도, 300+ DB 인스턴스 동시 렌더링 경합이 함께 겹치며 장애 대응 시작 속도가 느려진 상황이었습니다."
  architectureSummary: |-
    중앙 폴링 정책을 설계해 화면별 네트워크 편차를 제거했습니다.
    카드형 UI를 그리드 구조로 전환해 운영 탐색 밀도를 높였습니다.
    렌더 우선순위를 제어해 인터랙션 중 경합을 완화했습니다.
    회귀 자동화 게이트를 표준화해 릴리즈 안정성을 확보했습니다.
  measurementMethod: "React Profiler와 Performance API로 동일 운영 시나리오를 30회 반복 측정했고, 평균값과 p95를 기준값으로 관리했습니다."
  impacts:
    - value: "10초 -> 3초"
      label: "장애 인지 시간 70% 단축"
      description: "운영자가 이상 징후를 인지하고 대응을 시작하는 시간을 단축했습니다."
    - value: "73~82%"
      label: "인터랙션 지연 개선"
      description: "폴링-렌더 경합을 줄여 조작 응답성을 안정화했습니다."
    - value: "20%+"
      label: "렌더링 DOM 감소"
      description: "그리드 중심 구조 전환으로 고밀도 화면의 렌더링 비용을 줄였습니다."
  threads:
    - issueTitle: "분산 폴링 정책으로 운영 일관성과 반응성이 동시에 저하되는 문제"
      problems:
        - "화면마다 폴링 등록·해제 규칙이 달라 동일 장애 상황에서도 네트워크 동작이 달랐습니다."
        - "인터랙션 도중 폴링 리렌더가 겹쳐 조작 지연이 반복됐습니다."
      thoughtProcess: "화면별 임시 보정보다 중앙 정책을 먼저 설계해야 회귀와 운영 편차를 동시에 줄일 수 있다고 판단했습니다."
      actions:
        - "화면별 폴링 규칙을 단일 정책으로 재정의하고 Polling Manager 아키텍처 설계를 주도했습니다."
        - "React 전환 구간에서 TanStack Query 선언형 폴링 표준을 제안하고 팀 규칙으로 표준화했습니다."
        - "useFrozenData와 useDeferredValue 우선순위 전략을 정의해 인터랙션 중 렌더 경합을 제어했습니다."
      tradeOff: "A안(화면별 개별 폴링 유지)은 초기 구현이 단순했지만 정책 편차와 회귀 리스크가 컸습니다. B안(중앙 정책 통합)은 설계 복잡도가 증가했으나 운영 일관성을 확보할 수 있어 B안을 선택했고, 위험은 선언형 규칙과 회귀 테스트로 완화했습니다."
      comparison:
        beforeLabel: "화면별 개별 폴링"
        afterLabel: "중앙 정책 기반 폴링"
        before:
          - "화면마다 폴링 규칙이 달라 운영 시나리오 재현성이 낮았습니다."
          - "인터랙션 도중 폴링 리렌더가 겹쳐 조작 버벅임이 잦았습니다."
        after:
          - "중앙 정책으로 네트워크 동작을 통일해 운영 편차를 줄였습니다."
          - "렌더 우선순위 제어로 인터랙션 지연을 73~82% 개선했습니다."
      result: "동일 시나리오 30회 측정에서 인터랙션 지연이 73~82% 줄었고, 운영자는 조작 중 멈춤 없이 장애 대응 절차를 이어갈 수 있게 됐습니다."
    - issueTitle: "카드형 UI의 낮은 데이터 밀도로 장애 인지 시작점이 지연되는 문제"
      problems:
        - "카드 단위 탐색에서는 300+ 인스턴스 상태 비교를 한 화면에서 수행하기 어려웠습니다."
        - "반복 스캔과 화면 전환이 많아 대응 착수가 늦어졌습니다."
      thoughtProcess: "장애 대응 UX는 시각 장식보다 비교 속도가 핵심이므로 데이터 밀도 중심 구조로 전환해야 한다고 판단했습니다."
      actions:
        - "카드형 레이아웃 대비 그리드 전환안을 제안하고 운영 동선 재설계를 주도했습니다."
        - "중요 신호 우선 노출 규칙을 정의해 고밀도 화면에서도 우선순위 판단이 가능하도록 설계했습니다."
      tradeOff: "A안(카드형 유지)은 학습 비용이 낮았지만 비교 탐색 시간이 길었습니다. B안(그리드 전환)은 초기 적응 비용이 증가했지만 대량 상태 비교 효율이 높아 B안을 선택했고, 리스크는 정렬·필터 UX 가이드를 표준화해 완화했습니다."
      comparison:
        beforeLabel: "카드형 운영 화면"
        afterLabel: "그리드 중심 고밀도 화면"
        before:
          - "대규모 인스턴스 비교를 위해 반복 스캔과 전환이 필요했습니다."
          - "장애 인지 시작점이 늦어 대응 착수가 지연됐습니다."
        after:
          - "한 화면에서 상태 비교와 우선순위 판단이 가능해졌습니다."
          - "장애 인지 시간을 10초에서 3초로 단축했습니다."
      result: "고밀도 정보 배치 전환 후 장애 인지 시간이 10초에서 3초로 단축돼 운영 대응 시작 속도가 안정적으로 빨라졌습니다."
    - issueTitle: "대규모 동시 렌더링에서 DOM/레이아웃 비용이 급증하는 문제"
      problems:
        - "300+ 인스턴스 동시 렌더링에서 DOM 23,315개와 높은 레이아웃 재계산이 발생했습니다."
        - "INP가 280ms까지 상승해 인터랙션 품질이 불안정했습니다."
      thoughtProcess: "미세 튜닝보다 구조 전환과 회귀 체계를 함께 설계해야 개선 효과를 유지할 수 있다고 판단했습니다."
      actions:
        - "그리드 렌더링 경계를 재설계해 DOM 비용을 줄이는 구조 전환을 주도했습니다."
        - "Playwright 회귀 검증 시나리오를 정의하고 릴리즈 게이트로 표준화했습니다."
      tradeOff: "A안(국소 최적화 누적)은 단기 효과가 빠르지만 회귀 관리가 어려웠습니다. B안(구조 전환+회귀 게이트)은 초기 구현 비용이 높았지만 유지 비용을 낮출 수 있어 B안을 선택했고, 위험은 단계적 전환과 E2E 기준선으로 완화했습니다."
      result: "DOM 부담을 20% 이상 줄이고 회귀 테스트 게이트를 정착시켜, 성능 개선을 릴리즈 이후에도 재현 가능한 운영 품질로 연결했습니다."
  lessonsLearned: "운영 대시보드 성능은 단일 최적화가 아니라 정책 통합, 화면 구조 전환, 회귀 검증 표준화를 함께 설계할 때 지속된다는 점을 팀 기준으로 정리했습니다."
---

> 대시보드 코어 레이아웃·상태 관리·폴링 아키텍처 설계 및 구현 주도

#### Architecture Summary

- 중앙 폴링 정책을 설계해 화면별 네트워크 편차를 제거했습니다.
- 카드형 UI를 그리드 구조로 전환해 운영 탐색 밀도를 높였습니다.
- 렌더 우선순위를 제어해 인터랙션 중 경합을 완화했습니다.
- 회귀 자동화 게이트를 표준화해 릴리즈 안정성을 확보했습니다.

#### Context

- Vue 레거시 대시보드에서 폴링 규칙이 분산되어 운영 시나리오 재현성이 낮았습니다.
- 카드형 UI의 데이터 밀도 한계로 대규모 인스턴스 상태 비교가 느렸습니다.
- 300+ 인스턴스 동시 렌더링에서 DOM/레이아웃 비용이 급증해 반응성이 저하됐습니다.

#### Problem

- 장애 대응 착수 시간이 길어져 운영 리스크가 커졌습니다.
- 인터랙션 중 폴링 리렌더가 겹치며 조작 지연이 반복됐습니다.
- 화면 구조와 검증 체계가 분리돼 개선 효과를 유지하기 어려웠습니다.

#### Why It Was Hard

- 폴링 정책, 화면 구조, 렌더 성능 이슈가 동시에 얽혀 단일 최적화로는 해결되지 않았습니다.
- 고객별 운영 시나리오가 달라 정책 표준화와 커스터마이징을 함께 만족해야 했습니다.

#### Architecture Decision

A안(화면별 개별 폴링 + 카드형 유지)은 초기 구현이 단순했지만 정책 편차와 회귀 위험이 컸습니다. B안(중앙 정책 + 그리드 전환)은 설계 복잡도가 증가했지만 운영 일관성과 탐색 속도를 확보할 수 있어 B안을 선택했습니다. 증가한 복잡도 리스크는 선언형 규칙과 E2E 회귀 게이트로 완화했습니다.

#### Implementation Strategy

1. Polling Manager와 선언형 폴링 규칙을 설계하고 React 전환 과정에서 팀 표준으로 정의했습니다.
2. 카드형 화면을 그리드 중심 구조로 재설계해 우선순위 판단이 가능한 고밀도 레이아웃을 구축했습니다.
3. useFrozenData/useDeferredValue 전략을 적용해 인터랙션 우선 렌더를 보장했습니다.
4. Playwright 회귀 시나리오를 표준화해 릴리즈 전 성능/기능 회귀를 차단했습니다.

#### Result

- 장애 인지 시간: 10초 -> 3초(동일 운영 시나리오 30회 평균)
- 인터랙션 지연: 73~82% 개선(React Profiler/Performance API, 평균값·p95 기준)
- 렌더링 비용: DOM 20%+ 감소, 운영자 반복 스캔 횟수 감소

#### What I Learned

- 운영 화면 성능은 구조 전환과 검증 체계를 함께 설계해야 유지됩니다.
- 정책 표준화는 단순 코드 정리가 아니라 운영 품질의 일관성을 만드는 설계 활동입니다.
