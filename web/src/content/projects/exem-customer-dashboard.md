---
companyId: "exem"
title: "인스턴스 통합 모니터링 대시보드 개발"
company: "Exem"
description: "다양한 운영 시나리오를 단일 대시보드 구조로 통합하고, 장애 인지 시간을 10초에서 3초로 단축한 아키텍처 전환 사례"
dateStart: 2025-01-01
techStack: ["React", "TypeScript", "TanStack Table", "TanStack Query", "React Grid Layout", "Zustand", "Vite", "Playwright"]
priority: 1
storyThread:
  tldrSummary: "300~3,000대 인스턴스를 다루는 실시간 모니터링 대시보드와 그룹 단위 추세 분석 제품 2종을 개발했습니다. Vue 2 레거시의 폴링/영속 상태 구조를 먼저 정리한 뒤 API 전면 교체 시점에 React로 재구축했고, 허브 UX를 고밀도 그리드와 1단계 이동 동선으로 전환했습니다. 알림 기능은 테스트로 스펙을 고정한 후 마이그레이션했으며, 인터랙션 중 상태 반영 유예와 렌더 우선순위 조정으로 이상 징후 인지 시간을 10초에서 3초로, 조작 지연을 73~82% 개선했습니다."
  keyMetrics:
    - value: "10초 -> 3초"
      label: "이상 징후 인지 시간 단축"
      description: "동일 알람 시나리오에서 대응 시작까지의 시간을 10초에서 3초로 줄였습니다."
    - value: "73~82%"
      label: "조작 지연 개선"
      description: "상태 반영 유예와 렌더 우선순위 조정으로 인터랙션 응답성을 안정화했습니다."
    - value: "2종"
      label: "운영 제품 개발"
      description: "실시간 상태 모니터링 대시보드와 그룹 단위 추세 분석 제품을 동일 아키텍처로 운영 환경에 투입했습니다."
  coreApproach: "Vue 레거시 정리부터 React 재구축, 허브 UX 개선, 알림 마이그레이션 안정화, 인터랙션 최적화까지 하나의 연속된 제품 개선 흐름으로 설계했습니다."
  problemDefinition: "운영자는 300개 이상 인스턴스를 한 화면에서 빠르게 비교하고 이상 징후를 판단해야 했지만, 정보 밀도·상태 구조·제품 연계 동선·인터랙션 안정성이 동시에 병목인 상태였습니다."
  problemPoints:
    - "Vue 2 레거시 화면마다 폴링 규칙이 흩어져 운영 재현성이 낮았습니다."
    - "필터/조회 상태가 로컬 스토리지에 분산 저장돼 변경 영향 범위를 예측하기 어려웠습니다."
    - "API 전면 교체가 예정된 상황에서 전역 객체 의존이 커서 기능 추가보다 마이그레이션 비용이 더 높아지고 있었습니다."
    - "300개 이상 인스턴스를 한 화면에서 비교해야 했지만, 카드형 UI는 정보 밀도가 낮아 판단 속도를 떨어뜨렸습니다."
    - "허브 제품임에도 다른 제품으로의 이동 동선이 깊어 빠른 대응 흐름이 끊겼습니다."
    - "알림 기능은 스펙이 복잡해 마이그레이션 전에 동작을 먼저 고정할 필요가 있었습니다."
    - "3초 주기 폴링과 리사이즈·드래그 인터랙션이 겹칠 때 조작 지연이 발생했습니다."
  decisions:
    - title: "Vue 단계에서 폴링을 객체로 추상화"
      whyThisChoice: "갱신 주기를 선언적으로 제어해야 운영 시나리오를 일관되게 재현할 수 있었고, 화면별 타이머 분산 구조로는 이를 달성하기 어려웠습니다."
      alternative: "화면별 타이머를 유지하는 대신 폴링 객체 추상화로 통합"
      tradeOff: "초기 구조 설계 부담은 늘지만, 갱신 주기를 한 곳에서 관리해 운영 일관성과 향후 확장성을 확보할 수 있어 이 방향을 선택했습니다."
    - title: "영속 상태를 중앙화하고 버전 관리 구조로 개편"
      whyThisChoice: "상태 스키마가 코드 전반에 흩어지면 기능 추가 시 마이그레이션 경로를 설계할 수 없었고, API 전면 교체 직전에 이 문제를 먼저 해결해야 했습니다."
      alternative: "분산 저장을 유지하는 대신 상태 중앙화 + 버전 기반 마이그레이션 적용"
      tradeOff: "초기 전환 작업은 필요하지만 상태 스키마를 관리 가능하게 만들어 기능 확장과 유지보수 비용을 줄일 수 있어 중앙화를 선택했습니다."
    - title: "Vue 연장 대신 React + 사내 디자인 시스템 재구축"
      whyThisChoice: "API 전면 교체 시점에 전역 객체 의존이 큰 Vue 구조를 계속 확장하면 이후 전체 변경 비용이 더 커졌습니다."
      alternative: "Vue 확장을 유지하는 대신 React + 사내 디자인 시스템으로 재구축"
      tradeOff: "단기 개발 속도는 늦어지지만 API 교체 이후 구조적 부채를 줄이고 장기 변경 비용을 낮출 수 있어 재구축을 선택했습니다."
    - title: "허브 UX는 정보 밀도와 이동 깊이, 인터랙션 안정성을 우선"
      whyThisChoice: "허브 제품의 핵심은 장식보다 빠른 비교·판단·이동이며 실시간성보다 조작 안정성이 우선되는 구간이 분명했습니다."
      alternative: "카드형 UI와 깊은 이동 동선을 유지하는 대신 고밀도 그리드 + 1단계 진입 구조로 전환"
      tradeOff: "초기 적응 비용은 있지만 대량 인스턴스 비교 속도와 조작성을 동시에 개선할 수 있어 허브 UX 중심으로 전환했습니다."
  implementationHighlights:
    - "Vue 단계에서 폴링 객체 추상화와 영속 상태 중앙화·버전 관리를 적용해 레거시 기반을 정리했습니다."
    - "React와 사내 디자인 시스템으로 화면을 재구축해 API 전면 교체 이후 확장 가능한 구조를 확보했습니다."
    - "카드형 UI를 고밀도 그리드로 전환하고 제품 간 이동을 1단계 진입으로 줄여 허브 UX를 단순화했습니다."
    - "알림 기능은 테스트로 스펙을 고정한 뒤 마이그레이션하고 상태 반영 유예·렌더 우선순위 조정으로 조작성 저하를 완화했습니다."
  implementationGroups:
    - title: "Vue 단계"
      items:
        - "화면마다 분산된 타이머 폴링을 restart/add/stop 메서드 기반 객체로 추상화해 갱신 제어를 일원화했습니다."
        - "로컬 스토리지에 흩어진 필터/조회 상태를 중앙 저장소로 통합하고 버전 기반 마이그레이션 구조를 적용했습니다."
        - "JSDoc 타입 시스템 도입으로 레거시 코드의 변경 영향을 예측 가능하게 만들었습니다."
        - "실시간 지표, 추세 상세, Top 인스턴스 비교 화면을 운영 시나리오별로 확장했습니다."
    - title: "React 단계"
      items:
        - "API 전면 교체 시점에 React와 사내 디자인 시스템으로 대시보드를 재구축했습니다."
        - "카드형 UI를 고밀도 그리드로 전환해 대량 인스턴스 비교 흐름을 단순화했습니다."
        - "제품 간 연계를 1단계 진입으로 줄여 허브 내 이동 동선을 단축했습니다."
        - "알림 기능은 통합 테스트로 스펙을 먼저 고정한 뒤 마이그레이션했습니다."
        - "인터랙션 중 상태 반영 유예와 렌더 우선순위 조정으로 조작 지연을 줄였습니다."
  validationImpact:
    measurementMethod: "동일 알람 시나리오와 동일 조작 시나리오를 각각 30회 반복 측정하고 평균과 p95를 기준으로 이전 구조와 비교했습니다."
    metrics:
      - "장애 인지 시간: 10초 -> 3초"
      - "인터랙션 지연: 73~82% 감소"
    operationalImpact: "운영자는 한 화면에서 비교·판단·이동·대응 흐름을 끊지 않고 처리할 수 있게 됐습니다. 팀은 복잡 기능 마이그레이션의 품질 기준을 테스트로 고정하는 방식을 확보했습니다."
  lessonsLearned: "운영 대시보드는 폴링 정책, 영속 상태 구조, 정보 밀도, 이동 깊이를 함께 설계해야 효과가 유지됩니다.\n복잡한 기능 마이그레이션은 테스트로 스펙을 먼저 고정해야 위험을 줄일 수 있습니다.\n실시간 제품이라도 인터랙션 중에는 최신 데이터 반영보다 사용자의 조작 흐름이 더 중요할 수 있습니다."
---

## TL;DR

300~3,000대 인스턴스를 다루는 실시간 대시보드와 추세 분석 제품 2종을 개발하면서, Vue 2 레거시의 폴링/영속 상태를 먼저 정리하고 API 전면 교체 시점에 React로 재구축했습니다. 허브 UX를 고밀도 그리드와 1단계 이동으로 전환하고 알림 기능은 테스트 선행 마이그레이션으로 안정화했으며, 상태 반영 유예와 렌더 우선순위 조정으로 인지 시간 10초→3초, 조작 지연 73~82% 개선을 달성했습니다.

## 문제 정의

운영자는 300개 이상 인스턴스를 한 화면에서 빠르게 비교하고 즉시 대응해야 했지만, 카드형 UI의 정보 밀도 한계, 분산된 폴링·영속 상태 구조, 깊은 제품 연계 동선, 인터랙션 안정성 문제가 동시에 병목인 상황이었습니다.

## 핵심 의사결정

Vue 단계에서는 폴링 객체 추상화와 상태 중앙화·버전 관리를 먼저 적용하고, API 전면 교체 시점에는 Vue 연장보다 React 재구축이 총 변경 비용을 줄인다고 판단했습니다. 이후 허브 UX는 정보 밀도와 이동 깊이, 인터랙션 안정성을 우선해 고밀도 그리드·1단계 이동·상태 반영 유예 구조로 전환했습니다.

## 구현 전략

Vue 단계에서 레거시 구조를 정리한 뒤 React 단계에서 제품 UX와 마이그레이션 안정성을 함께 개선했습니다. 특히 알림 기능은 테스트로 동작 스펙을 먼저 고정한 후 이전해 위험을 통제했습니다.

## 검증 및 결과

동일 알람/조작 시나리오를 30회 반복 측정해 평균과 p95를 비교한 결과, 이상 징후 인지 시간은 10초에서 3초로 단축됐고 조작 지연은 73~82% 개선됐습니다.

## What I Learned

운영 대시보드 개선은 폴링 정책, 상태 구조, 정보 밀도, 이동 동선을 함께 설계할 때 유지됩니다. 복잡한 마이그레이션은 테스트로 스펙을 먼저 고정해야 안전하며, 실시간 제품에서도 인터랙션 구간은 최신성보다 조작 흐름을 우선하는 판단이 필요합니다.
