---
companyId: "exem"
title: "차세대 데이터베이스 성능 모니터링 제품 개발"
company: "Exem"
description: "도메인 기반 폼 아키텍처와 상태 지역화, i18n 검증 자동화를 통해 확장성과 운영 안정성을 동시에 확보한 제품 구조 설계 사례"
dateStart: 2025-01-01
techStack: ["React", "TypeScript", "Zustand", "Vite", "TanStack Query"]
priority: 3
storyThread:
  tldrSummary: "폼·상태·i18n 경계를 재설계해 기능 확장 속도와 운영 안정성을 동시에 확보했습니다."
  keyMetrics:
    - value: "5종"
      label: "차트 타입 확장 구조 정립"
      description: "line/bar/area/scatter/table을 도메인 단위로 분리해 확장 병목을 줄였습니다."
    - value: "약 70%"
      label: "스토어 보일러플레이트 감소"
      description: "상태 지역화로 초기화·정리 반복 코드를 크게 줄였습니다."
    - value: "0건"
      label: "i18n 키 누락 런타임 장애"
      description: "타입 자동 생성과 배포 전 스캔으로 누락을 사전 차단했습니다."
  coreApproach: "공통화보다 도메인 경계와 검증 시점을 먼저 설계해 확장 비용과 운영 리스크를 구조적으로 줄였습니다."
  problemDefinition: "차트 확장, 상태 수명 불일치, i18n 검증 지연이 누적돼 기능 추가 비용과 운영 리스크가 함께 커진 상태였습니다."
  problemPoints:
    - "단일 스키마 집중 구조로 새 타입 추가 때마다 중앙 변경 범위가 확대됐습니다."
    - "전역 상태 잔존으로 화면 전환 이후 수동 초기화 코드가 누적됐습니다."
    - "i18n 누락이 런타임에서 발견돼 배포 안정성과 리뷰 효율이 떨어졌습니다."
  decisions:
    - title: "단일 공통 스키마 대신 도메인 분리 구조 채택"
      whyThisChoice: "확장 병목과 회귀 위험을 줄이려면 공통 스키마 집중보다 변경 범위를 도메인 단위로 국소화해야 했습니다."
      alternative: "단일 공통 스키마를 유지하는 대신 차트 타입별 도메인 분리"
      tradeOff: "단일 공통 스키마는 초반 이해가 쉽지만 확장 병목이 커지고, 도메인 분리는 초기 설계 비용이 들더라도 영향 범위를 줄여 유지보수성을 높일 수 있어 분리 구조를 선택했습니다."
    - title: "전역 상태 대신 화면 수명 기반 상태 지역화"
      whyThisChoice: "상태 품질 문제는 API보다 수명 설계 불일치에서 발생해 화면 수명과 상태 수명을 정렬해야 했습니다."
      alternative: "전역 상태를 유지하는 대신 Provider 생명주기 기반 상태 지역화"
      tradeOff: "전역 상태는 단기 속도가 빠르지만 상태 누수가 커지고, 생명주기 기반 지역화는 초기 전환 비용이 있어도 유지보수성이 높아 지역화를 선택했습니다."
    - title: "런타임 검증 대신 빌드 단계 i18n 차단"
      whyThisChoice: "장애 발견 시점이 늦으면 반복 문제를 막기 어려워 컴파일 단계에서 실패시키는 정책이 필요했습니다."
      alternative: "런타임 검증을 유지하는 대신 타입 생성과 배포 전 스캔으로 빌드 단계 차단"
      tradeOff: "런타임 검증은 도입 비용이 낮지만 배포 리스크가 크고, 빌드 단계 차단은 자동화 비용이 있어도 장애를 선제적으로 막을 수 있어 빌드 단계 검증을 선택했습니다."
  implementationHighlights:
    - "차트 타입별 스키마·UI·어댑터 계층을 분리해 도메인 경계를 명확히 정의했습니다."
    - "Provider 생명주기 기반 지역 스토어 생성·정리 패턴과 팩토리 규칙을 표준화했습니다."
    - "번역 JSON 기반 TypeScript 타입 자동 생성으로 미등록 키 사용을 컴파일 단계에서 차단했습니다."
    - "배포 전 키 스캔과 Vitest/Playwright 회귀 시나리오를 운영 기준으로 고정했습니다."
  validationImpact:
    measurementMethod: "Vitest와 Playwright로 동일 회귀 시나리오를 20회 반복 실행해 평균 처리 시간과 실패율을 비교했습니다."
    metrics:
      - "차트 타입: 5종을 중앙 병목 없이 확장"
      - "스토어 보일러플레이트: 약 70% 감소"
      - "i18n 키 누락 런타임 장애: 0건 (20회 회귀)"
    operationalImpact: "기능 추가 시 변경 범위가 줄어 배포 예측 가능성이 높아지고 리뷰 반복 비용도 함께 줄었습니다."
  lessonsLearned: "확장성과 안정성은 분리된 목표가 아니라 경계 설계와 검증 시점 설계를 함께 할 때 동시에 달성됩니다.\n기능 추가 속도는 코드량보다 변경 영향 범위 통제가 좌우합니다."
---

## TL;DR

도메인 경계와 검증 시점을 재설계해 확장성과 안정성을 동시에 끌어올렸습니다.

## 문제 정의

폼 구조, 상태 수명, 검증 시점이 서로 어긋나며 기능 추가 비용과 운영 리스크가 함께 증가하고 있었습니다.

## 핵심 의사결정

도메인 분리, 상태 지역화, 빌드 단계 검증이라는 세 가지 의사결정을 한 세트로 실행했습니다.

## 구현 전략

변경 범위를 줄이는 구조를 먼저 설계하고, 자동 검증을 릴리즈 흐름에 내재화했습니다.

## 검증 및 결과

20회 회귀 기준에서 확장성 지표와 안정성 지표를 동시에 유지했습니다.

## What I Learned

확장 설계는 컴포넌트 분리보다 경계와 검증 시점을 어디에 두는지의 문제였습니다.
