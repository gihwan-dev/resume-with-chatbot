---
title: "차세대 데이터베이스 성능 모니터링 제품 개발"
company: "Exem"
description: "5종 시각화 차트의 도메인 기반 폼 아키텍처, Zustand 스토어 지역화, i18n 타입 자동 생성을 통해 확장성과 운영 안정성을 확보"
dateStart: 2025-01-01
updatedAt: 2026-02-16
techStack: ["React", "TypeScript", "Zustand", "Vite", "TanStack Query"]
priority: 3
storyThread:
  context: "차트 유형 확장, 상태 생명주기 불일치, i18n 키 검증 지연이 동시에 누적되며 기능 확장성과 운영 안정성이 함께 흔들리던 상황이었습니다."
  impacts:
    - value: "5종"
      label: "차트 타입 확장 구조 정립"
      description: "line/bar/area/scatter/table을 도메인 단위로 분리해 확장 시 중앙 스키마 병목을 줄였습니다."
    - value: "약 70%"
      label: "스토어 보일러플레이트 감소"
      description: "Provider 생명주기 기반 지역화 패턴으로 초기화/정리 반복 코드를 크게 축소했습니다."
    - value: "0건"
      label: "i18n 키 누락 런타임 장애"
      description: "타입 자동 생성과 사전 스캔으로 번역 키 누락을 배포 전에 차단했습니다."
  threads:
    - issueTitle: "단일 차트 폼 스키마 집중으로 확장 시 복잡도가 급증하는 문제"
      problems:
        - "5종 차트 설정이 단일 스키마에 몰려 조건 분기가 과도하게 증가했습니다."
        - "새 차트 추가 시 공통 스키마 수정이 반복되어 변경 영향 범위가 커졌습니다."
      thoughtProcess: "확장성을 확보하려면 공통화보다 도메인 경계 명확화가 우선이라고 판단했습니다."
      actions:
        - "차트 타입별 독립 스키마와 UI 컴포넌트로 분리했습니다."
        - "공통 입력 요소를 재사용 가능한 빌딩 블록 계층으로 추출했습니다."
        - "차트 타입 기반 검증 규칙과 어댑터 계층을 도입했습니다."
      result: "중앙 스키마 병목 없이 차트별 증분 확장이 가능한 구조를 확보했습니다."
    - issueTitle: "전역 Zustand 상태가 화면 생명주기와 분리되어 안정성이 떨어지는 문제"
      problems:
        - "화면 전환 후 상태 잔존과 수동 초기화 코드가 누적됐습니다."
        - "초기값 useEffect 패턴 증가로 무한 리렌더링 이슈가 반복됐습니다."
      thoughtProcess: "상태 품질을 높이려면 상태 수명 자체를 화면 수명과 일치시켜야 한다고 판단했습니다."
      actions:
        - "Provider 생명주기에 맞춘 지역 스토어 생성/정리 패턴을 적용했습니다."
        - "초기값 주입/훅 구성을 공통 팩토리 규칙으로 표준화했습니다."
      result: "스토어 설정 보일러플레이트를 약 70% 줄이고 화면 전환 안정성을 개선했습니다."
    - issueTitle: "i18n 키 누락이 런타임에서 발견되어 품질 리스크가 커지는 문제"
      problems:
        - "정의되지 않은 번역 키가 사용자 화면에 노출되는 장애가 발생했습니다."
        - "수동 검증 중심이라 리뷰 단계에서 반복 비용이 누적됐습니다."
      thoughtProcess: "검증 시점을 런타임 이후가 아니라 개발/빌드 단계로 당겨야 한다고 판단했습니다."
      actions:
        - "번역 JSON에서 TypeScript 타입을 자동 생성해 미등록 키 사용을 컴파일 단계에서 차단했습니다."
        - "배포 전 키 스캔 파이프라인을 추가했습니다."
      result: "i18n 키 누락 관련 런타임 장애 0건을 유지하는 검증 체계를 구축했습니다."
  lessonsLearned: "성격이 다른 문제도 도메인 경계 명확화와 검증 자동화를 함께 설계할 때 확장 속도와 운영 안정성을 동시에 확보할 수 있음을 확인했습니다."
---

#### 확장 가능한 시각화 시스템을 위한 도메인 기반 폼 아키텍처 전환

<h3 id="problem">Problem</h3>

* 5종 차트 타입(line, bar, area, scatter, table)의 설정 폼이 단일 스키마에 집중되어, 새 차트를 추가할 때마다 공통 스키마 수정이 반복되고 조건부 렌더링 복잡도가 빠르게 증가했습니다.
* UI와 스키마의 응집도가 낮아져, 버그 원인 추적과 기능 확장이 비효율적이었습니다.

<h3 id="decision">Decision</h3>

* 차트 타입별로 독립된 스키마와 UI 컴포넌트를 분리하고, 공통 입력 요소는 빌딩 블록 재사용 계층으로 추출해 조합 방식으로 폼을 구성했습니다.
* 차트 타입 기반 검증 규칙을 도입해 유효하지 않은 조합을 개발 단계에서 차단하도록 설계했습니다.
* 어댑터 패턴을 적용해 차트별로 상이한 입력 데이터를 표준화된 설정 포맷으로 변환하는 추상화 계층을 구축하여, 코어 로직과 개별 차트 간의 결합도를 낮췄습니다.

<h3 id="result">Result</h3>

* 신규 차트 추가 시 중앙 폼 정의 수정 없이 타입별 스키마·UI만 추가하면 되는 확장 구조를 확보해 기능 추가 리드타임을 줄였습니다.
* 스키마와 UI를 도메인 단위로 묶어 응집도를 높임으로써, 코드의 의도를 명확히 하고 변경 영향 범위를 국소화했습니다.

---

#### Zustand 스토어 지역화 및 상태 생명주기 최적화

**[기술 블로그: Zustand 스토어를 지역화하기](https://velog.io/@koreanthuglife/Zustand-%EC%8A%A4%ED%86%A0%EC%96%B4%EB%A5%BC-%EC%A7%80%EC%97%AD%ED%99%94%ED%95%98%EA%B8%B0)**

### Problem

* 전역 스토어가 화면 생명주기와 분리되어 상태가 화면 전환 후에도 잔존했고, 수동 초기화 코드가 누적되며 보일러플레이트와 유지보수 복잡도가 증가했습니다.
* 초기값 설정을 위한 `useEffect`의 사용이 늘어났고 이로 인한 무한 리렌더링 이슈가 자주 발생했습니다.

### Decision

* Provider 생명주기에 맞춘 지역 스토어 생성/정리 구조를 도입해, 상태 수명을 화면 수명과 일치시키는 표준 패턴을 적용했습니다.
* 스토어 생성 규칙을 공통 팩토리로 통일해 초기값 주입과 훅 구성을 반복 가능한 템플릿으로 정리했습니다.

### Result

* 스토어 설정 보일러플레이트를 약 70% 줄여 `Context API` + `Zustand store` 패턴의 진입 비용을 낮췄습니다.
* 상태 생명주기가 화면 생명주기와 자동으로 일치해 수동 초기화가 불필요해졌고, 화면 전환 안정성과 디버깅 효율이 개선됐습니다.

---

#### 다국어(i18n) 시스템 안정성 및 검증 자동화

### Problem

* 다국어 키 누락이 런타임에서 발견되어 사용자에게 원문 키가 노출됐고, 수동 확인 중심 검증으로 휴먼 에러가 반복됐습니다.
* 키 검증 시점이 늦어 코드 리뷰 단계에서 단순 오탈자 확인 비용이 누적됐습니다.

### Decision

* 번역 JSON에서 TypeScript 타입을 자동 생성해, 정의되지 않은 키 사용을 개발·빌드 단계에서 컴파일 에러로 사전 차단했습니다.
* 배포 전 자동 스캔 단계를 추가해 미등록 키를 릴리즈 전에 탐지하는 검증 파이프라인을 구성했습니다.

### Result

* 키 누락 관련 런타임 장애 0건을 달성해 사용자 노출 품질을 안정화했습니다.
* 키 검증이 자동화되어 리뷰 리소스를 핵심 로직 점검에 더 집중할 수 있게 됐습니다.

<h3 id="retrospective">Retrospective</h3>

* 차트 폼, 상태 저장소, i18n처럼 성격이 다른 문제도 결국 "도메인 경계 명확화 + 자동 검증" 패턴으로 수렴한다는 점을 확인했습니다.
* 기능 확장 속도와 운영 안정성은 별개의 목표가 아니라, 타입/런타임 검증을 초기에 설계할수록 함께 개선된다는 기준을 팀에 공유했습니다.
