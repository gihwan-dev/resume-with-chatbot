---
import { getCollection, render } from "astro:content"
import { PdfDownloadButton } from "@/components/pdf/pdf-download-button"
import { Separator } from "@/components/ui/separator"
import { getObsidianBlogPosts } from "@/lib/blog/obsidian-publish"
import { serializeResumeData } from "@/lib/pdf/serialize-resume"
import { RESUME_SUMMARY_BLOCKS_V1 } from "@/lib/resume-portfolio/mapping"
import Layout from "../layouts/Layout.astro"
import AwardSection from "./_sections/award-section.astro"
import BlogSection from "./_sections/blog-section.astro"
import CertificateSection from "./_sections/certificate-section.astro"
import ExperienceSection from "./_sections/experience-section.astro"
import HeroSection from "./_sections/hero-section.astro"
import ProjectSection from "./_sections/project-section.astro"
import SkillsSection from "./_sections/skills-section.astro"

const basics = await getCollection("basics")
const profile = basics[0]?.data
const resumeData = await serializeResumeData()
const skills = await getCollection("skills")
const skillsData = skills[0]?.data

const work = await getCollection("work")
const blogPosts = await getObsidianBlogPosts({ limit: 5 })

const certificates = await getCollection("certificates")
const awards = await getCollection("awards")

// Sort by date (descending)
const sortedWork = work.sort((a, b) => b.data.dateStart.valueOf() - a.data.dateStart.valueOf())

const sortedAwards = awards.sort((a, b) => b.data.date.valueOf() - a.data.date.valueOf())
const workWithContent = await Promise.all(
  sortedWork.map(async (entry) => {
    const { Content } = await render(entry)
    return { ...entry, Content }
  })
)

const awardsWithContent = await Promise.all(
  sortedAwards.map(async (entry) => {
    const { Content } = await render(entry)
    return { ...entry, Content }
  })
)
---

<Layout title={`${profile?.name} | AI와 함께하는 개발자 이력서`}>
  <main
    id="main-content"
    tabindex="-1"
    class="container max-w-4xl mx-auto py-12 px-4 sm:px-6 lg:px-8 min-h-screen"
  >
    <HeroSection profile={profile} />

    <div class="mt-4">
      <PdfDownloadButton data={resumeData} client:only="react" />
    </div>

    <Separator className="my-12" />

    {skillsData && <SkillsSection skills={skillsData} />}

    <Separator className="my-12" />

    <ExperienceSection experiences={workWithContent} />

    <Separator className="my-12" />

    <ProjectSection projects={RESUME_SUMMARY_BLOCKS_V1} />

    <Separator className="my-12" />

    <BlogSection posts={blogPosts} />

    <Separator className="my-12" />

    <CertificateSection certificates={certificates} />

    <Separator className="my-12" />

    <AwardSection awards={awardsWithContent} />
  </main>
</Layout>

<script>
  function setupAnalytics() {
    if (typeof window.gtag !== "function") return

    // 클릭 이벤트 위임: data-ga-event 속성이 있는 요소
    document.addEventListener("click", (e) => {
      const target = (e.target as HTMLElement).closest("[data-ga-event]") as HTMLElement | null
      if (!target) return

      const eventName = target.dataset.gaEvent!
      const params: Record<string, string> = {}

      for (const [key, value] of Object.entries(target.dataset)) {
        if (key.startsWith("ga") && key !== "gaEvent" && value) {
          const paramKey = key.slice(2).toLowerCase()
          params[paramKey] = value
        }
      }

      window.gtag("event", eventName, params)
    })

    // 섹션 뷰 추적: Intersection Observer
    const sections = document.querySelectorAll<HTMLElement>(
      "#profile, #skills, #experience, #projects, #blog, #certificates, #awards"
    )
    const viewed = new Set<string>()

    const observer = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting && !viewed.has(entry.target.id)) {
            viewed.add(entry.target.id)
            window.gtag("event", "section_view", {
              section_name: entry.target.id,
            })
          }
        }
      },
      { threshold: 0.3 }
    )

    for (const section of sections) {
      observer.observe(section)
    }
  }

  function setupScrollMemory() {
    // 1. Capture scroll on outbound portfolio clicks
    document.addEventListener("click", (e) => {
      const link = (e.target as HTMLElement).closest("a")
      if (!link) return
      
      const href = link.getAttribute("href")
      if (href && href.startsWith("/portfolio")) {
        // Prevent default, append query param, then navigate
        e.preventDefault()
        const currentScroll = Math.round(window.scrollY)
        
        let newHref = href
        const urlObj = new URL(href, window.location.origin)
        urlObj.searchParams.set("__bscroll", currentScroll.toString())
        
        // ClientRouter/ViewTransitions works best if we just use normal Astro router navigation 
        // by pushing state or just navigating. Window.location works fine with Astro ViewTransitions intercept
        window.location.assign(urlObj.toString())
      }
    })

    // 2. Restore scroll if returning from portfolio
    const params = new URLSearchParams(window.location.search)
    const storedScroll = params.get("__bscroll")
    
    if (storedScroll) {
      const scrollY = parseInt(storedScroll, 10)
      if (!isNaN(scrollY)) {
        // Use timeout to ensure DOM is settled (especially over view transitions)
        setTimeout(() => {
          window.scrollTo({ top: scrollY, behavior: "instant" })
          
          // Clean up the URL without triggering a reload or transition
          const newUrl = new URL(window.location.href)
          newUrl.searchParams.delete("__bscroll")
          window.history.replaceState({}, "", newUrl.toString())
        }, 50)
      }
    }
  }

  setupAnalytics()
  setupScrollMemory()
  
  // Setup again on view transitions
  document.addEventListener("astro:after-swap", () => {
    setupAnalytics()
    setupScrollMemory()
  })
</script>
